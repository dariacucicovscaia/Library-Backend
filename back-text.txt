RU:


Первое на что можно обратить внимание это архитектура нашего проекта, я в кратце расскажу о ней, после чего я уже подробней покажу каждый из пунктов.
	1. В первую очередь мы использовуем controller layer для получение и обработки http запросов с разрешеного адреса. Так же для возвращение какого либо ответа
	2. Дальше для обработки какой либо бизнес логики мы из контроллера вызываем мы используем service layer
	3. После чего уже результат выполненой логике в сервисе мы сохраняем в базу данных используя dao layer.
	   Dao layer служит нам для выполнение crud задач и выполнения более сложных и комплесных query.
	4. Как я уже упомянул мы контроллируем адреса с которых разрешены запросы на наше серверное приложение.
	   Это мы реализуем в нашем корс конфиге а его уже включаем в security конфиге который я подробнее еще покажу
	5. Дальше у нас идет auth package в котором мы держим классы отвечающее за авторизацию. Например authentificaton filter и authorization filter.
	6. Я еще в процессе покажу один из наших entity из domain package



Controller:

Для начала я начну с controller layer.
Перым делом мы даем знать спрингу что это наш контроллер, аннотацией @RestController что дает нам возможность использовать @ResponseBody и получать нужный нам ответ.
Дальше каждому методы мы обозначаем его http request method

Возьму как пример два контроллера и два метода.
Например в author controller у нас есть метод getAllPaginatedAndSortedAuthors который принимает в себя текущею страницу, количество элементов на странице,
параметр по которому нужно сортировать автора и sortOrder. Этот метод служит нам для того чтобы не вытаскивать за раз всех авторов из базы данных.
Ведь если у нас будут тысячи авторов там то это уже будет серьезная нагрузка на сервер. Так что этот метод служит нам в целях оптимизации данной операции.

Второй метод будет login с помощью которого пользователь заходит на свой аккаунт. В этом методе с помощью ResponseEntity мы контролируем response который мы вернем обратно.
В данном случае у нас все завернуто в try catch который ловит InvalidEmailOrPasswordException на случай если при логинации веден неверный пароль или имеил.
Это наш кастомный exception который выкидывает FORBIDDEN http status и который мы уже выкидывае в сервисе после должных проверок.
А если всё прошло хорошо то мы уже возвращаем ACCEPTED и заканчиваем логинацию юзера и возвращаем нужную дату из сервиса.


Чтобы реализовать какую либо логику мы обращаемся к сервису через интерфейсы. Мы соблюдаем принцип SOLID в котором могу отметить что присуствует Single Responsobility
то есть каждый интерфейс отвечает с определенную логику для каждого entity или же для каких то глобальных целей. Например сервис для регистрации и для автора.


Приведу один пример реализации некой логики. addBookToAuthor должен добавить автору уже существующею книгу. Метод получает id обоих.
После чего мы добавляем автору книгу с помощью метода у самового entity автора addBook.
А потом мы уже с помощью даоАвтора сохраняем обновленного автора.
То есть таким образом вся наша бизнесс логика находится в уровне layer и не выходит за ее рамки.


Перейдя в dao layer самая большая часть кода у нас сосредоточена в GenericDao ведь отсюда остальные интерфейсы наследуют базовые операции.
То есть наследуясь у GenericDao через интерфейсы мы уже передаем функционал классам что имплементят эти же интерфейсы.
Но нам все равно приходится добавлять к дао отвечающим за каждый entity дополнительные уникальные операции например так мы в UserDao ищем пользователя по его имеилу.


Теперь когда мы разобрали логику построения каких либо операций, можно перейти к security и разрашений которые имеют наши пользователи.
В security у нас есть 3 конфиг класса.
Корс конфиг для того чтобы контролировать адреса которые могут общаться с нашим сервером.
Password конфиг который содержит в себе bean для password encoder который мы используем для зашифроки паролей.
Security конфиг в котором мы уже настраиваем полностью безопастность нашего сервера.
Мы отключаем crsf в целях упросить разработку а так же упростить взаимодействие клиента и сервера. Ну и для того чтобы наше касстомная аутентификация не пострадала.
Подключаем корс конфиг.
И настраиваем permissions к нашем api.
В данном случае в этой части кода мы настраиваем только главные запросы которые общедоступны всем. А уже с помощью аннотации @EnableGlobalMethodSecurity мы можем
указывать перед каждым методом контроллера роли которые имеют доступ к этому запросу.